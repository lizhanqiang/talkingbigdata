### 侯世达定律 (Hofstadter's Law)

>即使考虑到侯世达定律，它也总是比你预期的要长。

>It always takes longer than you expect, even when you take into account Hofstadter's Law.

在估计需要多长时间开发时，你可能会听到此定律。软件开发似乎有这样一条定理，即我们往往不能准确地估计需要多长时间才能完成

### 墨菲定律 (Murphy's Law)

>凡是可能出错的事就一定会出错。

>Anything that can go wrong will go wrong.

---

>如果某件事可能出错，那么它一定会在最糟糕的时候发生。

>If something can go wrong, it will, at the worst possible time.

### 奥卡姆剃刀 (Occam's Razor)

 >如无必要，勿增实体。

>Entities should not be multiplied without necessity.

奥卡姆剃刀指出，在几种可能的解决方案之中，最有可能的解决方案便是概念和假设最少的那个。因为这个解决方案最为简单，只解决了问题，并且没有引入额外的复杂度和可能的负面后果

### 得墨忒耳定律 (The Law of Demeter)

>别和陌生人讲话。

>Don't talk to strangers.

得墨忒耳定律又称最少知识原则，是一条与面向对象语言有关的软件设计原则。遵循这一定律可以限制代码更改的范围，使其以后更容易维护、更安全。

### Unix 哲学 (The Unix Philosophy)

>Unix 哲学指软件组件应该很小，并专注于做一件特定的事情。将小而简单以及定义良好的单元组合在一起，而不是使用大而复杂的多用途程序

### 帕累托法则 (The Pareto Principle、The 80/20 Rule)

>生活中大多数事情不是均匀分布的。

>Most things in life are not distributed evenly.

这个原则也被称为**二八法则**、**重要的少数法则**、**因素稀疏原则**。微软 2002 年的报告表明，修复最常出现的 20％ 错误，将消除 Windows 和 Office 中 80％ 的 错误和崩溃

### KISS 原则 (The KISS Principle)

>保持简单和直白。

> Keep it simple, stupid.

如果大多数的系统能够保持简单而非复杂化，那么他们便能够工作在最佳状态。因此，简单性应该是设计时的关键指标，同时也要避免不必要的复杂度

### 你不需要它原则 (YAGNI)

>只有当你需要某些东西的时候，才去实现它们，而不是在你预见的时候。

>Always implement things when you actually need them, never when you just foresee that you need them.

这是 **Y**ou **A**ren't **G**onna **N**eed **I**t的缩写。极限编程原则告诫开发人员，他们应该只实现当前所需的功能，并避免实现未来需要的功能，仅在必要时才实现。遵守这一原则可以减小代码库大小，同时避免时间和生产力浪费在没有价值的功能上

### 破窗效应 (The Broken Windows Theory)

> 在破窗理论中认为，一些明显的犯罪迹象会导致进一步的、更严重的犯罪。以一幢有少许破窗的建筑为例，如果那些窗不被修理好，可能将会有破坏者破坏更多的窗户。最终他们甚至会闯入建筑内，如果发现无人居住，也许就在那里定居或者纵火

### 布鲁克斯法则 (Brooks's Law)

>软件开发后期，添加人力只会使项目开发得更慢。

>Adding human resources to a late software development project makes it later.

### 坎宁汉姆定律 (Cunningham's Law)

>在网络上想得到正确答案的最好方法不是提问题，而是发布一个错误的答案。

>The best way to get the right answer on the Internet is not to ask a question, it's to post the wrong answer.

### 邓巴数字 (Dunbar's Number)

>该定律根据猿猴的智力与社交网络推断出：人类智力将允许人类拥有稳定社交网络的人数是148人，四舍五入大约是150人

该定律又叫**150定律（Rule Of 150）**

### 盖尔定律 (Gall's Law)

>一个切实可行的复杂系统势必是从一个切实可行的简单系统发展而来的。从头开始设计的复杂系统根本不切实可行，无法修修补补让它切实可行。你必须由一个切实可行的简单系统重新开始。

>A complex system that works is invariably found to have evolved from a simple system that worked. A complex system designed from scratch never works and cannot be patched up to make it work. You have to start over with a working simple system.

### 古德哈特定律 (Goodhart's Law)

>当压力施于其上以进行控制时，任何观测到的统计恒性都倾向消散。

>Any observed statistical regularity will tend to collapse once pressure is placed upon it for control purposes.

---

>当一个措施本身成为目标时，它就不再是一个好的措施。

>When a measure becomes a target, it ceases to be a good measure.

根据这一定律，由测量驱动的优化反而可能导致测量结果本身的说服力下降。盲目使用一些过度严格筛选的方法 (KPIs) 可能会产生一些不良的影响。人们会倾向于用“钻空子”的行为去做局部优化，从而满足一些特定的度量标准，而不会在意整体的结果。

### 汉隆的剃刀 (Hanlon's Razor)

>能解释为愚蠢的，就不要解释为恶意的。

>Never attribute to malice that which is adequately explained by stupidity.

### 哈伯特定律 (Hutber's Law)

>改善即恶化。

>Improvement means deterioration.

例如，某个端点的响应延迟减少，就可能导致请求流中的吞吐量和容量问题进一步增加，并影响到另一个完全不同的子系统。

### 技术成熟度曲线 (The Hype Cycle or Amara's Law)

>我们倾向于过高估计技术在短期内的影响，并低估长期效应。

>We tend to overestimate the effect of a technology in the short run and underestimate the effect in the long run.

### 林纳斯定律 (Linus's Law)

>足够多的眼睛，就可让所有问题浮现。

>Given enough eyeballs, all bugs are shallow.

### 摩尔定律 (Moore's Law)

>集成电路中的晶体管数量大约每两年翻一番。

>The number of transistors in an integrated circuit doubles approximately every two years.

### 帕金森定理 (Parkinson's Law)

>在工作能够完成的时限内，工作量会一直增加，直到所有可用时间都被填满为止。

>Work expands so as to fill the time available for its completion.

该理论认为，团队在截止日期之前效率低下，然后在截止日期前赶紧完成工作，从而使实际截止日期变得随意。

### 过早优化效应 (Premature Optimization Effect)

>过早优化是万恶之源。

>Premature optimization is the root of all evil.

### 帕金森琐碎定理 (The Law of Triviality)

>常见的例子是委员会批准核电站的计划，他们大部分时间都在讨论自行车棚的结构，而不是电厂本身等更为重要的设计。如果没有大量的专业知识或者准备，很难给非常大的复杂主题讨论提供宝贵的意见。但是，人们希望看到更多意见。因此，他们倾向于将大量时间集中在很容易推敲，但不一定被看重的小细节上。

### 帕金森定律（Parkinson's Law）

>一个不称职的官员，可能有三条出路，第一是申请退职，把位子让给能干的人；第二是让一位能干的人来协助自己工作；第三是任用两个水平比自己更低的人当助手。这第一条路是万万走不得的，因为那样会丧失许多权利；第二条路也不能走，因为那个能干的人会成为自己的对手；看来只有第三条路最适宜。于是，两个平庸的助手分担了他的工作，他自己则高高在上发号施令，他们不会对自己的权利构成威胁。两个助手既然无能，他们就上行下效，再为自己找两个更加无能的助手。如此类推，就形成了一个机构臃肿、人浮于事、相互扯皮、效率低下的领导体系

### 不要重复你自己原则 (The DRY Principle)

>系统中，每一块知识都必须是单一、明确而权威的。

>Every piece of knowledge must have a single, unambiguous, authoritative representation within a system.

DRY 是 **Do not Repeat Yourself** 的缩写。这个原则旨在帮助开发人员减少代码的重复性，并将公共代码保存在一个地方

### 90-9-1 法则 (90–9–1 Principle 、1% Rule)

>90-9-1 法则表明，在诸如维基这样的互联网社区中，90% 的用户只看内容并不参与互动，9% 的用户会参与讨论，而只有 1% 的用户会创造内容

### 康威定律 (Conway's Law)

>这个定律说明了系统的技术边界可以反应一个组织的结构，它通常会在改进组织时被提及。康威定律表明，如果一个组织被分散成许多小而无联系的单元，那么它开发的软件也是小而分散的。如果组织是更多地围绕以功能或服务为导向的**垂直**结构，那么软件系统也会反映这一点。

### 切斯特森围栏 (Chesterson's Fence)

>在了解现有情况背后的原因之前，不应该进行改进。

>Reforms should not be made until the reasoning behind the existing state of affairs is understood.

### 死海效应 (The Dead Sea Effect)

>"... 那些更有才华，更有效率的 IT 工程师最有可能离开——消失 ... （而那些倾向于）留下来的“剩下的人”——是最没有才华和效率的 IT 工程师。"

>"... [T]he more talented and effective IT engineers are the ones most likely to leave - to evaporate ... [those who tend to] remain behind [are] the 'residue' — the least talented and effective IT engineers."

### 呆伯特法则 (The Dilbert Principle)

>公司会倾向于系统地将工作能力差的员工提升到管理层，以使他们脱离工作流程。

>Companies tend to systematically promote incompetent employees to management to get them out of the workflow.

### 鲁棒性原则 (The Robustness Principle or Postel's Law)

>在自己所做的事情上要保守, 在接受别人的事情上要自由。

>Be conservative in what you do, be liberal in what you accept from others.

### 单一功能原则 (The Single Responsibility Principle)

>每个模块或者类只应该有一项功能。

>Every module or class should have a single responsibility only.

### 开闭原则 (The Open/Closed Principle)

>实体应开放扩展并关闭修改。

>Entities should be open for extension and closed for modification.

### 里氏替换原则 (The Liskov Substitution Principle)

>可以在不破坏系统的情况下，用子类型替换类型。

>It should be possible to replace a type with a subtype, without breaking the system.

### 接口隔离原则 (The Interface Segregation Principle)

>不应强制任何客户端依赖于它不使用的方法。

>No client should be forced to depend on methods it does not use.

### 依赖反转原则 (The Dependency Inversion Principle)

>高级模块不应该依赖于低级实现。

>High-level modules should not be dependent on low-level implementations.